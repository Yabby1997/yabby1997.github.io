---
layout: post
title: "📚 혼자하는 C++ 공부 -3- "
description: "2019년 여름방학, 혼자했던 C++공부를 정리해보자."
date: 2020-01-04
feature_image: images/thumbnail_cpp.png
tags: [CNU, C++]
---
# 👀 C++
[위키독스](https://wikidocs.net/book/1413)를 주로 참조하여 공부했다.  
이전 글 [📚 혼자하는 C++ 공부 -2-](https://yabby1997.github.io/cpp_2) 보러가기

## Shallow copy
```cpp
#include<iostream>
#include<cstring>

using std::cout;
using std::endl;

class student{
private :
    char* name;
    int age;
public :
    student(){
        name = "";
        age = 19;
    }
    
    student(char* newName, int newAge){
        int len = strlen(newName) + 1;
        name = new char[len];
        strcpy(name, newName);
        age = newAge;
    }
    /*
    student(const student& copy){
        int len = strlen(copy.name) + 1;
        name = new char[len];
        strcpy(name, copy.name);
        age = copy.age;
    }
    */
    void changeName(char* newName){
        delete [] name;
        int len = strlen(newName) + 1;
        name = new char[len];
        strcpy(name, newName);
    }
    
    void showInfo(){
        cout << "NAME : " << name << endl;
        cout << "AGE : " << age << endl;
    }
    
    ~student(){
        delete [] name;
        cout << "DESTRUCTOR CALLED" << endl;
    }
};

int main(void){
    student a("apple", 23);
    student b(a);
    a.showInfo();
    b.showInfo();
    a.changeName("lemon");
    a.showInfo();
    b.showInfo();
    return 0;
}
```
>NAME : apple
AGE : 23
NAME : apple
AGE : 23
NAME : lemon
AGE : 23
NAME : lemon
AGE : 23
DESTRUCTOR CALLED
*** Error in `./a.out': double free or corruption (fasttop): 0x0000000001d8ec20 ***
Aborted (core dumped)

복사생성자를 정의해주지 않고 복사생성을하면 포인터변수의 경우 주소만 복사되므로 복사생성된 객체와 원래의 객체가 같은 메모리 공간을 가리키는 ***얕은복사***가 이뤄진다. 위의 코드에서 복사생성자를 따로 정의 해주지 않았고 `name`변수가 포인터변수이므로 객체 `a`와 `b`의 `name`이 같은 공간을 가리키게 됐고, `a`가 소멸되며 `b`의 `name`도 함께 소멸되어 오류가 발생한 것이다.

## Deep copy
```cpp
#include<iostream>
#include<cstring>

using std::cout;
using std::endl;

class student{
private :
    char* name;
    int age;
public :
    student(){
        name = "";
        age = 19;
    }
    
    student(char* newName, int newAge){
        int len = strlen(newName) + 1;
        name = new char[len];
        strcpy(name, newName);
        age = newAge;
    }
    
    student(const student& copy){
        int len = strlen(copy.name) + 1;
        name = new char[len];
        strcpy(name, copy.name);
        age = copy.age;
    }
    
    void changeName(char* newName){
        delete [] name;
        int len = strlen(newName) + 1;
        name = new char[len];
        strcpy(name, newName);
    }
    
    void showInfo(){
        cout << "NAME : " << name << endl;
        cout << "AGE : " << age << endl;
    }
    
    ~student(){
        delete [] name;
        cout << "DESTRUCTOR CALLED" << endl;
    }
};

int main(void){
    student a("apple", 23);
    student b(a);
    a.showInfo();
    b.showInfo();
    a.changeName("lemon");
    a.showInfo();
    b.showInfo();
    return 0;
}
```
>NAME : apple
AGE : 23
NAME : apple
AGE : 23
NAME : lemon
AGE : 23
NAME : apple
AGE : 23
DESTRUCTOR CALLED
DESTRUCTOR CALLED

얕은복사의 예제에 복사생성자를 추가로 구현하여 값을 복사하도록 해주었다. 복사생성자에서 `name`에 대해 새로운 공간을 만들어 값을 넣어주도록 했기 때문에 얕은복사처럼 같은 메모리공간을 가리키지 않게되고, `a`가 소멸되어도 `b`에는 문제가 생기지 않는다. 

## Object as function parameter
```cpp
#include<iostream>

using std::cout;
using std::endl;

class data{
private :
    int value;
public :
    data(int newValue){
        value = newValue;
    }
    
    ~data(){
        cout << "DESTRUCTOR CALLED" << endl;    
    }
    
    void showData(){
        cout << "VALUE : " << this->value << endl;
    }
};

void showData_Parameter(data dt){
    cout << "SHOW DATA OF PARAMETER" << endl;
    dt.showData();
}

int main(void){
    data a(3);
    a.showData();
    showData_Parameter(a);
    return 0;
}
```
>VALUE : 3
SHOW DATA OF PARAMETER
VALUE : 3
DESTRUCTOR CALLED
DESTRUCTOR CALLED

함수의 인자로 객체를 전달하게되면 객체가 복사되어 전달되고, 함수가 실행된 뒤 소멸자가 실행된다. 전역함수 `showData`는 인자로 `data`객체를 받아 `data`의 `showData`를 호출하고 종료된다. `main`에서 전역함수 `showData`를 호출했으므로 객체 `a`가 복사되어 함수가 실행되고 소멸이 일어난다. `main`이 종료될 때 원래의 `a`도 소멸되므로 소멸자가 총 2번 호출되는 것이다. 

## Const object
```cpp
#include<iostream>

using std::cout;
using std::endl;

class data{
private : 
    int value;
public :
    data(int newValue){
        value = newValue;
    }
    
    void add(int operand){
        value = value + operand;
    }
    
    void showInfo() const{
        cout << value << endl;
    }
};

int main(void){
    data a(3);
    const data b(3);
    a.showInfo();
    b.showInfo();
    a.add(3);
    //b.add(3).
    a.showInfo();
    b.showInfo();
    return 0;
}
```
>3                                                                                                                                                                                                
3                                                                                                                                                                                                
6                                                                                                                                                                                                
3 

`const`객체는 `const`함수만 사용가능하다. `const`로 생성된 객체는 멤버변수의 값을 바꿀 수 없다. 

## Friend class
```cpp
#include<iostream>

using std::cout;
using std::endl;

class one;
class two;

class one{
friend class two;
private : 
    int value;
public :
    one(){
        value = 1;
    }
    void friendInfo(two& tw);
    void showInfo(){
        cout << this->value << endl;
    }
};

class two{
private :
    int value;
public :
    two(){
        value = 2;
    }
    void friendInfo(one& on);
    void showInfo(){
        cout << this->value << endl;
    }
friend class one;
};

void one::friendInfo(two& tw){
    cout << tw.value << endl;
}
void two::friendInfo(one& on){
    cout << on.value << endl;
}

int main(void){
    one a;
    two b;
    a.showInfo();
    b.showInfo();
    a.friendInfo(b);
    b.friendInfo(a);
    return 0;
}
```
>1                                                                                                                                                                                                
2                                                                                                                                                                                                
2                                                                                                                                                                                                
1

`friend class`를 통해 클래스의 내부 어디에서나 다른 클래스를 친구 클래스로 선언해줄 수 있다. 이렇게 친구 클래스를 선언해주면 ***해당 클래스의 `private`에 접근할 수 있게된다..!***
